/************************************
 Decryption algorithm, generated by Cruz 
 Vargas to solve HW1 from Jonathan Katz's 
 Introduction to Classical Cryptography
 ************************************/

#include <stdio.h>
#include <stdlib.h>     /* strtol */
#define MAX_KEY_LENGTH 10

int main(){
    unsigned char ch1, ch2;
    int byte;
    FILE *fpIn, *fpOut;
    int i;
    char distribution[MAX_KEY_LENGTH][255];//array of key lengths & distributions for each key length
    
//    unsigned char key[KEY_LENGTH] = {0x00, 0x00};
    
    /* of course, I did not use the all-0s key to encrypt */
    
    fpIn = fopen("ctext.txt", "r");
    fpOut = fopen("ptext_decoded.txt", "w");
    
    //Find the key length
    for (int n = 1; n < MAX_KEY_LENGTH; n++) {
        
        fprintf(stdout, "\nn = %d\n", n);
        i=1;

        while (fscanf(fpIn, "%02X", &byte) != EOF) {
            
            if (byte != 13) {
                fprintf(stdout, "%02d = ", byte);
                fprintf(stdout, "%c & i=%d\n", byte, i);
            }
            
            if (i % n == 0) {
                //every nth character
                printf("logged\n");
                //log the frequency at N, digit
                distribution[n][byte] ++;
            }
            
            i++;

        }
        rewind(fpIn);
        
        if (n == 1) {
            fprintf(stdout, "95=%d 96=%d 97=%d 98=%d 99=%d 100=%d\n", distribution[n][95],distribution[n][96],distribution[n][97],distribution[n][98],distribution[n][99],distribution[n][100]);
            
            for (int j = 0; j < 255; j++) {
                if (distribution[n][j] != 0) {
                    fprintf(stdout,"[%d][%d]\n", n,j);
                }
            }
        }
    }
    //Find the key
    

    
    
    fclose(fpIn);  
    fclose(fpOut);  
    return 0;
}
