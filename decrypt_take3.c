/************************************
 Decryption algorithm, generated by Cruz 
 Vargas to solve HW1 from Jonathan Katz's 
 Introduction to Classical Cryptography
 ************************************/

#include <stdio.h>
#include <stdlib.h>     /* strtol */
#include <math.h>
#include <string.h>
#define MAX_KEY_LENGTH 24
#define LOGGING 0

int main(){
    unsigned char ch1, ch2;
    int byte;
    FILE *fpIn, *fpOut;
    int i;
    int distribution[MAX_KEY_LENGTH][255];//array of key lengths & distributions for each key length
    float probability[MAX_KEY_LENGTH];
    int max[MAX_KEY_LENGTH], min[MAX_KEY_LENGTH]; //max and min of ASCII as integers
    float files_char_count[MAX_KEY_LENGTH];
    int key_length;
    
    //unclear why the fuck this is necessary - distribution array not be initialized to 0
    memset(distribution, 0, sizeof(distribution[0][0]) * MAX_KEY_LENGTH * 255);
    memset(max, 0, sizeof(max[0]) * MAX_KEY_LENGTH);
    memset(min, 0, sizeof(max[0]) * MAX_KEY_LENGTH);
    memset(probability, 0, sizeof(probability[0]) * MAX_KEY_LENGTH);
    
    fpIn = fopen("ctext.txt", "r");
    fpOut = fopen("ptext_decoded.txt", "w");
    
    //log the distribution of character occurence
    for (int n = 1; n < MAX_KEY_LENGTH; n++) {
        
        i=1;
        files_char_count[n] = 0;

        while (fscanf(fpIn, "%02X", &byte) != EOF) {
            if (i % n == 0) {
                distribution[n][byte] ++; //track occurence in corresponding int slot of array
                // if (min[n] == 0) {min[n] = byte;}
                // if (max[n] < byte) {max[n] = byte;}
                files_char_count[n]++; //total number of chars considered
            }
            i++;

        }
        rewind(fpIn); //be kind, rewind
    }
    
    //get the key length distributions
    float max_probability;
    float a;
    for (int k = 1; k < MAX_KEY_LENGTH ; k++) {
        for (int l = 0; l < 255; l++) {
            //((number of times shown) / (files_char_count))^2
            a = powf((((float) distribution[k][l]) / (files_char_count[k]) ),2);
            //add probability squared to that key length's sum
            probability[k] = (float)probability[k] + (float)a;
            //record max probability as key length
            if (probability[k] > max_probability) {
                max_probability = probability[k];
                key_length = k;//k;
            }
        }
        //log out the probabilities
        fprintf(stdout, "length %02d gives %1.3f probability with %02.0f chars\n", k, probability[k], files_char_count[k]);
    }
    fprintf(stdout,"key length is likely %d\n\n", key_length);
    
    //now that we know the length, find the actual key
    char key[key_length];//an array to store the guess at the key
    memset(key, 0, sizeof(key[0]) * key_length);

    //start a ith byte,
    //collect every ith byte,
    char analysis[key_length][255];
    float shifted_char_count[key_length];
    float key_probability[key_length];
    int eligible_chars = 127-32;
    float xored_permutations[key_length + 1][eligible_chars + 32][255][1];
    float collapsed_probabilities[key_length + 1][eligible_chars + 32][1];
    float number_of_chars[key_length];

    memset(xored_permutations, 0, sizeof(xored_permutations[0][0][0][0]) * key_length * 255 * (eligible_chars + 32)); 
    memset(key_probability, 0, sizeof(key_probability[0]) * key_length);
    memset(analysis, 0, sizeof(analysis[0][0]) * key_length * (255));
    memset(max, 0, sizeof(max[0]) * MAX_KEY_LENGTH);
    memset(min, 0, sizeof(max[0]) * MAX_KEY_LENGTH);



    for (int key_shift = 0; key_shift < key_length +1; key_shift++) { //each shift, through end of key length
        //start at i
        int current_char = 0;

        while (fscanf(fpIn, "%02X", &byte) != EOF) {
            if(((current_char - key_shift) % key_length)== 0){ // the character you're on (shifted back by i) is a multiple of key length
                
                int xored_char;
                for (int xored_with = 32; xored_with < 127; xored_with++)
                {   
                    //shift that character by xoring it with every eligible character
                    xored_char = byte ^ xored_with;
                    // if (xored_char > 127 || xored_char < 32)
                    // {
                    //     // printf("for shift:%d char:%c is not a valid option (%c before)\n", key_shift, xored_char, byte);
                    // }
                    //record the frequency of xored characters for each i shift
                    xored_permutations[key_shift][xored_with][xored_char][0] ++;
                    // printf("%d, %c, %d, %d %0.0f\n",key_shift, byte, xored_with, xored_char, xored_permutations[key_shift][xored_with][xored_char][0]);
                }
                number_of_chars[key_shift]++;
            }
            current_char++; // counter of the character you're on
        }
        rewind(fpIn);
    }
    

    float max_probability_key;
    int potential_key_char;
    int decoded_char;
    float b;
    //check the xored chars to see if xored with resulted in potential actual keys
    for (int outer = 0; outer < key_length ; outer++) {
        printf("round %d with %1.0f chars\n", outer, number_of_chars[outer]);
        max_probability_key = 0;
        
        for (potential_key_char = 32; potential_key_char < (eligible_chars + 32); potential_key_char++)
        {
            for (decoded_char = 0; decoded_char < 127; decoded_char++)
            {
                //sum xored permutations for each outer and potential key

                collapsed_probabilities[outer][potential_key_char][0] = collapsed_probabilities[outer][potential_key_char][0] + 
                powf((xored_permutations[outer][potential_key_char][decoded_char][0] / number_of_chars[outer]),2);
               if (xored_permutations[outer][potential_key_char][decoded_char][0] != 0)
               {
//printf("\t\txored_permutations[%d][%c][%c]:%1.0f\n", outer, potential_key_char, decoded_char, xored_permutations[outer][potential_key_char][decoded_char][0]);
               }

                if ((collapsed_probabilities[outer][potential_key_char][0] > max_probability_key)) 
                {   
                    key[outer] = potential_key_char;
//                    printf("%d with prob %0.4f\n", potential_key_char, collapsed_probabilities[outer][potential_key_char][0]);
                    max_probability_key = collapsed_probabilities[outer][potential_key_char][0];
                }
                // if (xored_permutations[outer][potential_key_char][decoded_char])
                // {
                //     /* code */
                // }

            }
            if ((collapsed_probabilities[outer][potential_key_char][0] > 0.055) && (collapsed_probabilities[outer][potential_key_char][0] < 0.075))
            {
              printf("\tcollapsed_prob[%d][%c]:%0.6f\n", outer, potential_key_char, collapsed_probabilities[outer][potential_key_char][0]);
            }

        }
        

     // key[outer] = 'a'; //most likely key
    }



    //then xor with every possible option  (32 to 127)
    //check to see if output characters are between 32 and 127
        //if not, eliminate this character option
    //sum probabilities generated (occurences) / (characters considered)
    //how many options are left?
    
    for (int h = 0; h < key_length +1; h++) {
        fprintf(stdout,"%c",key[h]);
    }
    printf("\n");


    for (int q = 0; q < key_length; q++)
    {
        // printf("-----ROUND %d-----\n\n", q);
        for (int r = 0; r < 127; ++r)
        {
            // printf("collapsed_prob[%d][%c]:%0.4f\n", q, r, collapsed_probabilities[q][r][0]);
        }
        printf("\n");
    }

    
    //now that we know the key, print the decrypted text out to a file
    int lol;
        while (fscanf(fpIn, "%02X", &byte) != EOF) {
            fprintf(stdout, "%c", byte ^ key[lol % key_length]);
            lol++;
        }
        printf("\n");
    
    
    
    fclose(fpIn);
    fclose(fpOut);  
    return 0;
}
